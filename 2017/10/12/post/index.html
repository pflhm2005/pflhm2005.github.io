<!DOCTYPE html><html><head><meta charset="utf-8"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="yes" name="apple-touch-fullscreen"><meta content="telephone=no,email=no" name="format-detection"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"><link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon"><link href="https://fonts.googleapis.com/css?family=Rubik" rel="stylesheet"><script src="https://use.fontawesome.com/adaf0e149c.js"></script><link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/monokai_sublime.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/post.css"><link rel="stylesheet" href="/css/markdown-github.css"><title>书生小龙</title><script src="/js/googleAnalytics.js"></script></head><body><div id="postContainer"><div id="postTop"><h4 id="logo">Life Is Short</h4><br><br><h2 id="postTitle">Java中Math.random()源码浅析</h2><br><span aria-hidden="true" class="postTime fa fa-calendar">2017-10-12</span><br><br></div><section id="articleDiv"><p><hr></p>
<p><blockquote></p>
<p>好久没写博客，忙的有点晕。</p><br><p>开始从零自学java消遣一下，看书有点脑阔疼，不如看看源码！(๑╹◡╹)ﾉ”””</p><br></blockquote><br><p>​    JS中Math调用的都是本地方法，底层全是用C++写的，所以完全无法观察实现过程，Java的工具包虽然也有C/C++的介入，不过也有些是自己实现的。</p><br><p>​    本篇文章主要简单阐述Math.random()的实现过程。</p><br><p>​    Math隶属于java.lang包中，默认加载。本身是一个final类，方法都是静态方法，所以使用的时候不需要生成一个实例，直接调用Math.XX就行了。</p><br><p>​    一步一步观察该方法，首先是java.lang.Math：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</div><div class="line">  <span class="comment">// 大量静态变量与方法</span></div><div class="line">  <span class="comment">// …</span></div><div class="line">  </div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Random randomNumberGenerator;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initRNG</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (randomNumberGenerator == <span class="keyword">null</span>) </div><div class="line">      randomNumberGenerator = <span class="keyword">new</span> Random();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">random</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (randomNumberGenerator == <span class="keyword">null</span>) initRNG();</div><div class="line">    <span class="keyword">return</span> randomNumberGenerator.nextDouble();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// …other</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><p>​    这里面与random相关的操作有3个：</p><br><p>1、声明一个私有静态Random类randomNumberGenerator</p><br><p>2、若randomNumberGenerator未初始化，调用new Random()将其初始化</p><br><p>3、若randomNumberGenerator已经初始化，调用nextDouble方法并将其值返回</p><br><p><strong>tips</strong>：synchronized关键字代表同步执行此方法，Java为多线程，所以为了保证randomNumberGenerator对象只被初始化一次，需要该关键字。比如两个线程同时调用了Math.random()，线程A发现rXX未被初始化，进入initRNG调用new Random()方法。此时线程B也发现了rXX未被初始化，但是initRNG是同步方法，所以挂起等待线程A执行完毕。当线程A执行完后把rXX初始化了，所以在initRNG中的if判断，线程B会直接返回。</p><br><p>​    所以简单来讲，random方法会在第一次调用时生成一个randomNumberGenerator对象，并调用其nextDouble方法生成随机数，之后的调用就只要持续调用此方法返回随机数就行了。</p><br><p>​    下面来看Random类是个什么鬼，来源于java.util.Random：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Random</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</div><div class="line">  <span class="comment">// 静态变量</span></div><div class="line">  <span class="comment">/<em>* use serialVersionUID from JDK 1.1 for interoperability </em>/</span></div><div class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3905348978240129619L</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong seed;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> multiplier = <span class="number">0x5DEECE66DL</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> addend = <span class="number">0xBL</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> mask = (<span class="number">1L</span> &lt;&lt; <span class="number">48</span>) - <span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="comment">// constructor</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Random</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>(++seedUniquifier + System.nanoTime()); &#125;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">long</span> seedUniquifier = <span class="number">8682522807148012L</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Random</span><span class="params">(<span class="keyword">long</span> seed)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.seed = <span class="keyword">new</span> AtomicLong(<span class="number">0L</span>);</div><div class="line">    setSeed(seed);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 设置种子</span></div><div class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSeed</span><span class="params">(<span class="keyword">long</span> seed)</span> </span>&#123;</div><div class="line">    seed = (seed ^ multiplier) &amp; mask;</div><div class="line">    <span class="keyword">this</span>.seed.set(seed);</div><div class="line">    haveNextNextGaussian = <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 产生大数字</span></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> bits)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> oldseed, nextseed;</div><div class="line">    AtomicLong seed = <span class="keyword">this</span>.seed;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">      oldseed = seed.get();</div><div class="line">      nextseed = (oldseed <em> multiplier + addend) &amp; mask;</div><div class="line">    &#125; <span class="keyword">while</span> (!seed.compareAndSet(oldseed, nextseed));</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(nextseed &gt;&gt;&gt; (<span class="number">48</span> - bits));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 生成随机数</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">nextDouble</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (((<span class="keyword">long</span>)(next(<span class="number">26</span>)) &lt;&lt; <span class="number">27</span>) + next(<span class="number">27</span>))</div><div class="line">      / (<span class="keyword">double</span>)(<span class="number">1L</span> &lt;&lt; <span class="number">53</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 其他不关心的方法</span></div><div class="line">  <span class="comment">// nextBytes(bytes [])</span></div><div class="line"></div><div class="line">  <span class="comment">// nextInt</span></div><div class="line"></div><div class="line">  <span class="comment">// nextInt(int)</span></div><div class="line"></div><div class="line">  <span class="comment">// nextLong</span></div><div class="line"></div><div class="line">  <span class="comment">// nextBoolean</span></div><div class="line"></div><div class="line">  <span class="comment">// nextFloat</span></div><div class="line"></div><div class="line">  <span class="comment">// Serializable相关</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><p>​    上述代码剔除了大量的注释，还有一些不需要关心的方法，本文只关注Math.random()调用相关方法。</p><br><p>​    对于这个类，首先来看看它的构造函数，理论上new一个Random实例是需要一个long类型的整数作为参数，但是代码用了this使其默认调用new Random(long)这个构造函数。而在构造函数中又生成了一个新类并赋值给实例变量seed，关于这个AtomicLong类其实没啥好讲的，简单看一下就行：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicLong</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1927816293512124184L</span>;</div><div class="line"></div><div class="line">  <span class="comment">// valueOffset相关…</span></div><div class="line"></div><div class="line">  <span class="comment">// 实例变量</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value;</div><div class="line">  <span class="comment">// 构造函数</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AtomicLong</span><span class="params">(<span class="keyword">long</span> initialValue)</span> </span>&#123;</div><div class="line">    value = initialValue;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AtomicLong</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">  <span class="comment">// 方法</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> newValue)</span> </span>&#123;</div><div class="line">    value = newValue;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 这个也会用到 但是不用关心具体实现</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">long</span> expect, <span class="keyword">long</span> update)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> unsafe.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, expect, update);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 其余不需要关心（其实我也看不懂）的方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><p>​    如果思想简单一点，可以看出这个类也很简单，初始化传参赋值，set设置，get获取，多简单！</p><br><p>​    现在回到Random类的构造函数中，实例变量被赋值，类的value为初始化的0(后缀L代表这是一个long类型整数)。下一步调用setSeed，传入构造函数的long类型seed变量(不是seed类)，其值为：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">++seedUniquifier + System.nanoTime()</div><div class="line"><span class="comment">// private static volatile long seedUniquifier = 8682522807148012L(8.6825e+15);</span></div><div class="line"><span class="comment">// 2^52 ~ 2^53</span></div><div class="line"><span class="comment">// 写文章时测试 =&gt; System.nanoTime() =&gt; 13230650355964(1.323e+13);</span></div></pre></td></tr></table></figure><br><p>​    其中第一个变量为一个固定值，每次加1，另外一个为System.nanoTime()，该方法返回一个与当前时间相关的数字，具体我不关心。</p><br><p>​    两个相加后，作为初始种子出传入setSeed方法中，方法第一步会对seed进行二次计算：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">seed = (seed ^ multiplier) &amp; mask;</div><div class="line"><span class="comment">// private final static long multiplier = 0x5DEECE66DL;(25214903917 =&gt; 2.5214e+10)</span></div><div class="line"><span class="comment">// 2^34 ~ 2^35</span></div><div class="line"><span class="comment">// private final static long mask = (1L &lt;&lt; 48) - 1;(2^48-1 =&gt; 0111…1 =&gt; 2^48 = 2.8147+e14)</span></div></pre></td></tr></table></figure><br><p>​    此处进行的是位运算，这里不用关心具体数值，只关注可能得到的最大最小值。</p><br><p>​    ^ =&gt; 异或运算：3 ^ 4 =&gt; 011 ^ 100 = 111 =&gt; 7(不一样置1，否则置0)</p><br><p>​    可以看出，两个数字异或运算，假设其中较大的二进制位数为n，结果一定是小于等于2^n-1，比如3^4，4为100三位，所以结果一定小于等于2^3-1，即7。</p><br><p>​    &amp; =&gt; 与运算：3 &amp; 4 =&gt; 011 &amp; 100 = 000 =&gt; 0(都为1置1，否则置0)</p><br><p>​    可以看出，与运算的结果总是小于等于较小的那个数。</p><br><p>​    </p><br><p>​    这样来再来看之前的位运算：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">seed(<span class="number">2</span>^<span class="number">52</span> ~ <span class="number">2</span>^<span class="number">53</span>) ^ multiplier(<span class="number">2</span>^<span class="number">34</span> ~ <span class="number">2</span>^<span class="number">35</span>) =&gt; <span class="number">0</span> ~ (<span class="number">2</span>^<span class="number">53</span>-<span class="number">1</span>)</div></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(seed ^ multiplier)(<span class="number">0</span> ~ <span class="number">2</span>^<span class="number">53</span>-<span class="number">1</span>) &amp; mask(<span class="number">2</span>^<span class="number">48</span>-<span class="number">1</span>) =&gt; <span class="number">0</span> ~ <span class="number">2</span>^<span class="number">48</span>-<span class="number">1</span></div></pre></td></tr></table></figure><br><p>​    结论是种子的范围是在0 ~ 2^48-1之间。</p><br><p>​    测试代码：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</div><div class="line">    pro b = <span class="keyword">new</span> pro();</div><div class="line">    System.out.println(b.getValue());</div><div class="line">    <span class="comment">// 256403749474577</span></div><div class="line">    <span class="comment">// 256458702577093</span></div><div class="line">    <span class="comment">// 256431328421593</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">pro</span></span>&#123;</div><div class="line">  <span class="keyword">long</span> seed = <span class="number">8682522807148012L</span> + System.nanoTime();</div><div class="line">  <span class="keyword">long</span> multiplier = <span class="number">0x5DEECE66DL</span>;</div><div class="line">  <span class="keyword">long</span> mask = (<span class="number">1L</span> &lt;&lt; <span class="number">48</span>) - <span class="number">1</span>;</div><div class="line">  <span class="function"><span class="keyword">long</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> (seed ^ multiplier) &amp; mask;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><p>​    构造函数调用完后，现在来看nextDouble，这个方法除去位运算，本质上就是调用了两次next方法：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">nextDouble</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> (((<span class="keyword">long</span>)(next(<span class="number">26</span>)) &lt;&lt; <span class="number">27</span>) + next(<span class="number">27</span>))</div><div class="line">    / (<span class="keyword">double</span>)(<span class="number">1L</span> &lt;&lt; <span class="number">53</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><p>​    所以直接看next方法：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> bits)</span> </span>&#123;</div><div class="line">  <span class="keyword">long</span> oldseed, nextseed;</div><div class="line">  AtomicLong seed = <span class="keyword">this</span>.seed;</div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    oldseed = seed.get();</div><div class="line">    nextseed = (oldseed </em> multiplier + addend) &amp; mask;</div><div class="line">  &#125; <span class="keyword">while</span> (!seed.compareAndSet(oldseed, nextseed));</div><div class="line">  <span class="keyword">return</span> (<span class="keyword">int</span>)(nextseed &gt;&gt;&gt; (<span class="number">48</span> - bits));</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><p>​    方法内部声明了2个long类型种子：oldseed、nextseed，通过get方法取得之前位运算得到的seed赋值给oldseed，然后再次通过运算得到一个nextseed的值，并传给seed.compareAndSet(oldseed, nextseed)方法中。</p><br><p>​    关于这个方法，源码里是这样的：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// java.util.concurrent.atomic.AtomicLong;</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicLong</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">long</span> expect, <span class="keyword">long</span> update)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> unsafe.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, expect, update);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// sun.misc.Unsafe.java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object obj, <span class="keyword">long</span> offset,<span class="keyword">long</span> expect, <span class="keyword">long</span> update)</span></span>;</div></pre></td></tr></table></figure><br><p>​    这个方法是个内部方法，也就是用C/C++实现的，所以有兴趣的自己去看源码，这里贴一个blog：</p><br><p>​    <a href="http://www.cnblogs.com/Mainz/p/3546347.html" target="_blank" rel="external">http://www.cnblogs.com/Mainz/p/3546347.html</a></p><br><p>​    方法的用处简单讲也很简单，比较oldseed与内存中预期的值，如果符合，就将nextseed放进去。</p><br><p>​    </p><br><p>​    这里的运算也不管具体数值，oldseed * multiplier按最大计算会出现溢位，截取成long类型后的大小不确定，所以按照与运算这里的范围依然是0 ~ mask，即0 ~ 2^48-1。</p><br><p>​    最后返回(int)(nextseed &gt;&gt;&gt; (48 - bits))，这里对结果进行类型处理，贴一个类型范围图：</p><br><table><br><thead><br><tr><br><th style="text-align:center">基本类型</th><br><th style="text-align:center">最小值</th><br><th style="text-align:center">最大值</th><br></tr><br></thead><br><tbody><br><tr><br><td style="text-align:center">byte</td><br><td style="text-align:center">-2^7</td><br><td style="text-align:center">2^7 - 1</td><br></tr><br><tr><br><td style="text-align:center">short</td><br><td style="text-align:center">-2^15</td><br><td style="text-align:center">2^15 - 1</td><br></tr><br><tr><br><td style="text-align:center">int</td><br><td style="text-align:center">-2^31</td><br><td style="text-align:center">2^31 - 1</td><br></tr><br><tr><br><td style="text-align:center">long</td><br><td style="text-align:center">-2^63</td><br><td style="text-align:center">2^63 - 1</td><br></tr><br></tbody><br></table><br><p>​    若结果是大于int类型最大值，超出的部分会被直接截取砍掉。</p><br><p>​    最后看nextDouble的计算式：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(((<span class="keyword">long</span>)(next(<span class="number">26</span>)) &lt;&lt; <span class="number">27</span>) + next(<span class="number">27</span>)) / (<span class="keyword">double</span>)(<span class="number">1L</span> &lt;&lt; <span class="number">53</span>)</div></pre></td></tr></table></figure><br><p>​    传入的bits分别为26与27，这时返回的随机数为：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">int</span>)(nextseed &gt;&gt;&gt; <span class="number">22</span>) 与 (<span class="keyword">int</span>)(nextseed &gt;&gt;&gt; <span class="number">21</span>)</div></pre></td></tr></table></figure><br><p>​    &gt;&gt;&gt;为无符号右移，具体意思就不解释了。</p><br><p>​    得到的结果范围大概是 0 ~ 2^26(27)-1，理论上在这里是不会超过int的最大值。</p><br><p>​    当seed(测试代码中的tmp)为mask时，此时计算会达到最大值：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(((<span class="keyword">long</span>)(<span class="number">1L</span> &lt;&lt; <span class="number">53</span>)-<span class="number">1</span> ) / (<span class="keyword">double</span>)(<span class="number">1L</span> &lt;&lt; <span class="number">53</span>)</div></pre></td></tr></table></figure><br><p>​    测试代码：</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</div><div class="line">    testb bb = <span class="keyword">new</span> testb();</div><div class="line">    <span class="keyword">long</span> a = (<span class="keyword">long</span>)bb.getNext(<span class="number">26</span>);</div><div class="line">    <span class="keyword">long</span> b = bb.getNext(<span class="number">27</span>);</div><div class="line">    <span class="keyword">double</span> c = <span class="number">1L</span> &lt;&lt; <span class="number">53</span>;</div><div class="line">    <span class="keyword">double</span> d = ((a&lt;&lt;<span class="number">27</span>) +b)/c;</div><div class="line">    <span class="comment">// 0.99999999…</span></div><div class="line">    System.out.println(d);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">testb</span></span>&#123;</div><div class="line">  <span class="keyword">long</span> tmp = (<span class="number">1L</span>&lt;&lt;<span class="number">48</span>)-<span class="number">1</span>;</div><div class="line">  <span class="comment">// long tmp = 0 =&gt; 0.0</span></div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(tmp &gt;&gt;&gt; (<span class="number">48</span> - num));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br><p>​    当测试代码中tmp为0时，计算结果为最小值0。</p><br><p>​    每一次调用nextDouble，会生成不一样的seed，也就会返回不一样的数字。</p><br><p>​    这样就是整个随机数生成过程。</p><br><p>​    完结，撒花ヽ(ﾟ∀ﾟ)ﾒ(ﾟ∀ﾟ)ﾉ </p>
</section></div><script src="/js/jquery.min.js"></script><script src="/js/highlight.min.js"></script><script src="/js/start.js"></script></body></html>